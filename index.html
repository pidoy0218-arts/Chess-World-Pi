<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chess Arena Pi - Raw Test</title>
  <style>
    body {
      margin: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      background: #222;
      font-family: Arial, sans-serif;
      color: #fff;
      height: 100vh;
    }
    #board {
      display: grid;
      grid-template-columns: repeat(8, 60px);
      grid-template-rows: repeat(8, 60px);
      border: 4px solid #000;
      margin-top: 20px;
    }
    .square {
      width: 60px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 40px;
      cursor: pointer;
      user-select: none;
    }
    .light {
      background: #F5DEB3; /* light brown */
    }
    .dark {
      background: #8B4513; /* dark brown */
    }
    .piece.white {
      color: #f8f8f0; /* ivory */
    }
    .piece.black {
      color: #333; /* ebony */
    }
    #info {
      display: flex;
      justify-content: space-between;
      width: 500px;
      margin-top: 10px;
    }
    .player {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .captured {
      margin-top: 5px;
      font-size: 18px;
    }
    #moves {
      margin-top: 15px;
      width: 500px;
      background: #111;
      padding: 10px;
      height: 120px;
      overflow-y: auto;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <h2>Chess Arena Pi (Raw Test)</h2>

  <div id="info">
    <div class="player" id="player1">
      <div id="player1Id">White</div>
      <div id="timer1">05:00</div>
      <div class="captured" id="captured1"></div>
    </div>
    <div class="player" id="player2">
      <div id="player2Id">Black</div>
      <div id="timer2">05:00</div>
      <div class="captured" id="captured2"></div>
    </div>
  </div>

  <div id="board"></div>
  <div id="moves"></div>

  <script>
    // ----------- Utility -----------
    const U = {
      inBounds: (r,c) => r>=0 && r<8 && c>=0 && c<8,
      clone: (state) => JSON.parse(JSON.stringify(state))
    };

    const initialBoard = [
      ["r","n","b","q","k","b","n","r"],
      ["p","p","p","p","p","p","p","p"],
      ["","","","","","","",""],
      ["","","","","","","",""],
      ["","","","","","","",""],
      ["","","","","","","",""],
      ["P","P","P","P","P","P","P","P"],
      ["R","N","B","Q","K","B","N","R"]
    ];

    let state = {
      board: initialBoard,
      side: "w",
    };

    let selected = null;
    let movesEl = document.getElementById("moves");
    let timerInterval;
    let time1 = 300, time2 = 300;

    // ----------- Board Render -----------
    const boardEl = document.getElementById("board");
    function render(){
      boardEl.innerHTML = "";
      for(let r=0;r<8;r++){
        for(let c=0;c<8;c++){
          const sq = document.createElement("div");
          sq.className = "square " + ((r+c)%2===0?"light":"dark");
          sq.dataset.r = r; sq.dataset.c = c;
          const piece = state.board[r][c];
          if(piece){
            const span = document.createElement("span");
            span.className = "piece " + (piece === piece.toUpperCase() ? "white" : "black");
            span.textContent = pieceIcon(piece);
            sq.appendChild(span);
          }
          boardEl.appendChild(sq);
        }
      }
    }

    function pieceIcon(p){
      const icons = {
        "P":"♙","R":"♖","N":"♘","B":"♗","Q":"♕","K":"♔",
        "p":"♟","r":"♜","n":"♞","b":"♝","q":"♛","k":"♚"
      };
      return icons[p];
    }

    // ----------- Timers -----------
    function startTimers(){
      clearInterval(timerInterval);
      timerInterval = setInterval(()=>{
        if(state.side==="w"){ time1--; updateTimers(); if(time1<=0) endGame("b","time"); }
        else { time2--; updateTimers(); if(time2<=0) endGame("w","time"); }
      },1000);
    }
    function updateTimers(){
      document.getElementById("timer1").textContent = format(time1);
      document.getElementById("timer2").textContent = format(time2);
    }
    function format(t){
      let m = Math.floor(t/60), s = t%60;
      return `${m.toString().padStart(2,"0")}:${s.toString().padStart(2,"0")}`;
    }

    // ----------- Game Logic -----------
    function kingPos(board, side){
      const k = side==="w"?"K":"k";
      for(let r=0;r<8;r++)for(let c=0;c<8;c++)
        if(board[r][c]===k) return {r,c};
      return null;
    }

    function other(side){ return side==="w"?"b":"w"; }

    // ✅ Fixed attacked() (pawns only attack diagonals)
    function attacked(board, attackerSide, r, c){
      // pawns
      const pawn = attackerSide==="w"?"P":"p";
      const pawnOffsets = attackerSide==="w"?[[1,-1],[1,1]]:[[-1,-1],[-1,1]];
      for(const [dr,dc] of pawnOffsets){
        const rr=r+dr, cc=c+dc;
        if(U.inBounds(rr,cc) && board[rr][cc]===pawn) return true;
      }
      // knights
      const N = attackerSide==="w"?"N":"n";
      for(const [dr,dc] of [[2,1],[1,2],[-1,2],[-2,1],[-2,-1],[-1,-2],[1,-2],[2,-1]]){
        const rr=r+dr, cc=c+dc;
        if(U.inBounds(rr,cc) && board[rr][cc]===N) return true;
      }
      // bishops/queens
      const B = attackerSide==="w"?"B":"b", Q = attackerSide==="w"?"Q":"q";
      for(const [dr,dc] of [[1,1],[1,-1],[-1,1],[-1,-1]]){
        let rr=r+dr, cc=c+dc;
        while(U.inBounds(rr,cc)){
          const p=board[rr][cc];
          if(p){ if(p===B||p===Q) return true; break; }
          rr+=dr; cc+=dc;
        }
      }
      // rooks/queens
      const R = attackerSide==="w"?"R":"r";
      for(const [dr,dc] of [[1,0],[-1,0],[0,1],[0,-1]]){
        let rr=r+dr, cc=c+dc;
        while(U.inBounds(rr,cc)){
          const p=board[rr][cc];
          if(p){ if(p===R||p===Q) return true; break; }
          rr+=dr; cc+=dc;
        }
      }
      // king
      const K = attackerSide==="w"?"K":"k";
      for(let dr=-1;dr<=1;dr++)for(let dc=-1;dc<=1;dc++){
        if(dr===0&&dc===0) continue;
        const rr=r+dr, cc=c+dc;
        if(U.inBounds(rr,cc) && board[rr][cc]===K) return true;
      }
      return false;
    }

    // ✅ Fixed legalMoves() (checks stalemate properly)
    function legalMoves(state){
      const {board, side} = state;
      const moves = [];
      for(let r=0;r<8;r++)for(let c=0;c<8;c++){
        const p = board[r][c];
        if(!p) continue;
        const isWhite = p===p.toUpperCase();
        if((side==="w")!==isWhite) continue;
        // simple moves: pawns, knights, sliders, king
        // (your existing full move generation logic here — omitted for brevity in this snippet)
        // ...
      }
      // filter moves that leave king in check
      const legal=[];
      for(const m of moves){
        const st=U.clone(state);
        makeMove(st,m,true);
        const kp=kingPos(st.board,side);
        if(!attacked(st.board,other(side),kp.r,kp.c)) legal.push(m);
      }
      return legal;
    }

    function makeMove(st, move, silent){
      st.board[move.to.r][move.to.c]=st.board[move.from.r][move.from.c];
      st.board[move.from.r][move.from.c]="";
      st.side=other(st.side);
      if(!silent) {
        movesEl.innerHTML += `${move.san}<br>`;
        sendMove(move); // 🔌 hook for multiplayer
      }
      return true;
    }

    // ✅ Game end check
    function checkEnd(){
      const legal=legalMoves(state);
      const kp=kingPos(state.board,state.side);
      const inCheck=kp && attacked(state.board,other(state.side),kp.r,kp.c);
      if(legal.length===0){
        if(inCheck) endGame(other(state.side),"checkmate");
        else endGame("draw","stalemate");
      }
    }

    function endGame(winner,reason){
      clearInterval(timerInterval);
      let msg="";
      if(winner==="draw") msg=`Game drawn (${reason})`;
      else msg=`${winner==="w"?"White":"Black"} wins by ${reason}`;
      movesEl.innerHTML+=`<b>${msg}</b><br>`;
    }

    // ----------- Multiplayer Hooks ----------- 
    function sendMove(move){
      console.log("Send move:",move);
      // TODO: later: integrate with Pi SDK / server
    }
    function receiveMove(move){
      makeMove(state,move);
      render();
    }

    // ----------- Start Game -----------
    render();
    startTimers();
    updateTimers();
  </script>
</body>
</html>
